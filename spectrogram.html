<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
</head>
<body>
<style>
</style>
<script src="http://d3js.org/d3.v3.js"></script>
<script>
var nChans = 8;
var gridSize = 1;
var gridPad = 0;
var borderPad = 1;
var chanPad = 10;
var nSamples = 50;
var passFilter = d3.range(5,55);
var tick;
var eegData;
var nested;
var color;

//randomized data for testing
var embedded = [];
var lembed = 5000;
var wembed = 125;
var aembed = 10;
for (var i = 0; i<lembed*nChans; i++) {
	embedded.push([]);
	for (var j = 0; j<wembed; j++) {
		embedded[i].push(Math.random()*aembed*aembed);
	}
}
var color = d3.scale.linear()
			.domain([0, 10, 100])
			.range(["white", "red", "gray"])
			.clamp(true)
;
color = d3.scale.linear()
			.domain([0,5,10, 100])
			.range(["blue","green","yellow","red"])
			.clamp(true)
;
var thisColor;
var canvas = document.createElement("canvas");
document.body.appendChild(canvas);
var context = canvas.getContext("2d");
var test;
//this means if we don't find the data file we use the random noise above instead
//function callback(d,f){try{d3.csv(d,f);}catch(e){f(null,embedded);}}
function callback(d,f){try{d3.text(d,f);}catch(e){f(null,embedded);}}
callback("alpha_fft.csv",function(error, data) {
	if (typeof(data)=="string") {
		data = d3.csv.parseRows(data);
	}
	//it seems like we ought to run some kinds of data processing before the update function
	nObs = Math.floor(data.length/nChans);
	nBands = d3.entries(data[0]).length;
	useBands = passFilter.length;
	for (var i = 0; i < data.length; i++) {
		data[i]["row"] = i;
		data[i]["channel"] = i%nChans;
		data[i]["obs"] = Math.floor(i/nChans);
	}
	nested = d3.nest()
		.key(function (d) {return d.channel;})
		.key(function (d) {return d.obs;})
		.entries(data)
	;
	canvas.width = nSamples*(gridPad+gridSize)+2*borderPad;
	canvas.height = nChans*chanPad + 2*borderPad + nChans*passFilter.length*(gridPad+gridSize);
	/*for(var chan = 0; chan < nChans; chan++) {
		context.rect(	borderPad,
									borderPad + chan*(chanPad+passFilter.length*(gridPad+gridSize)),
									nSamples*(gridPad+gridSize),
									passFilter.length*(gridPad+gridSize)
		);
	}
	context.lineWidth = 0.5;
	context.strokeStyle = "black";
	context.stroke();
	context.lineWidth = 0;*/
	function update() {
		tick+=1;
		for (var chan = 0; chan < nChans; chan++) {
			for (var samp = 0; samp < nSamples; samp++) {
				for (var band = 0; band < passFilter.length; band++) {
					thisColor = color(nested[chan].values[samp+tick].values[0][band]);
					context.fillStyle = thisColor;
					context.fillRect(	samp*(gridPad+gridSize) + borderPad,
														chan*(chanPad + (gridSize+gridPad)*passFilter.length) + (band+passFilter[0])*(gridSize+gridPad) + borderPad,
														gridSize,gridSize);
				}
			}
		}
		if ((tick+nSamples)*nChans>=data.length) {
			clearInterval(loop);
		}
	}

	tick = 0;
	update();
	var loop = setInterval(function() {update();}, 250);
});
</script>
</body>
</html>
